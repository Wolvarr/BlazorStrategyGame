@page "/maingame/{gameId}"
@using Models
@using Enums;
@using System.Net.Http
@using StrategyGameClient.DTOs.CreateGame;
@using Blazor.Extensions
@using Blazor.Extensions.Canvas.Canvas2D

@inject HttpClient Http
@inject IJSRuntime JsRuntime;

<h1>Strat Game</h1>
<button class="btn btn-primary" @onclick="MoveLeft">
    Move left
</button>

<button class="btn btn-primary" @onclick="MoveRight">
    Move right
</button>

<div id="canvasContainer" oncontextmenu="return false;" style="position: fixed; opacity: 1; background-color: black; width: 80%; height: 80%" @onmousemove="MoveScreen" @onmouseup="RightMouseUp">
    <BECanvas @ref="_canvas">

    </BECanvas>

    <div>
        <img @ref="_orcWarrior" hidden src="assets/OrcWarrior.png" />
        <img @ref="_plainTile" hidden src="assets/PlainTile.png" />
        <img @ref="_waterTile" hidden src="assets/WaterTile.png" />
        <img @ref="_snowTile" hidden src="assets/SnowTile.png" />
        <img @ref="_stoneTile" hidden src="assets/StoneTile.png" />
        <img @ref="_magmaTile" hidden src="assets/MagmaTile.png" />

    </div>

</div>


@code {

    #region CONSTANTS

    [Parameter]
    public string GameId { get; set; }

    BECanvasComponent _canvas;

    ElementReference _orcWarrior;

    ElementReference _plainTile;
    ElementReference _waterTile;
    ElementReference _snowTile;
    ElementReference _stoneTile;
    ElementReference _magmaTile;

    Canvas2DContext _context;

    #endregion

    private Game Game = null;


    private void MoveLeft(MouseEventArgs e)
    {
        if (Game.GameObjects.First().Position.RenderNumber > 0)
            Game.GameObjects.First().Position = Game.Tiles.SingleOrDefault(y => y.RenderNumber == Game.GameObjects.First().Position.RenderNumber - 1);
    }

    private void MoveRight(MouseEventArgs e)
    {
        if (Game.GameObjects.First().Position.RenderNumber < Game.Tiles.Count - 1)
            Game.GameObjects.First().Position = Game.Tiles.SingleOrDefault(y => y.RenderNumber == Game.GameObjects.First().Position.RenderNumber + 1);
    }

    public double lastButtonPositionX { get; set; } = 0;

    public double lastButtonPositionY { get; set; } = 0;

    private void MoveScreen(MouseEventArgs e)
    {
        if (e.Buttons == 2)
        {
            if (lastButtonPositionX == 0 && lastButtonPositionY == 0)
            {
                lastButtonPositionX = e.ClientX;
                lastButtonPositionY = e.ClientY;
            }


            Game.ScreenPositionX -= (e.ClientX - lastButtonPositionX) / 3;
            Game.ScreenPositionY -= (e.ClientY - lastButtonPositionY) / 3;
            lastButtonPositionX = e.ClientX;
            lastButtonPositionY = e.ClientY;

        }
        //Game.ScreenPositionX -= 10;
        //Game.ScreenPositionY += 0.1;

    }

    private void RightMouseUp(MouseEventArgs e)
    {
        if (e.Button == 2)
        {
            lastButtonPositionX = 0;
            lastButtonPositionY = 0;
        }
    }


    protected override Task OnInitializedAsync()
    {

        return base.OnInitializedAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            var createGameDTO = await Http.GetFromJsonAsync<CreateGameDTO>("engine/getmap/" + this.GameId);
            this.Game = new Game(createGameDTO);
            await JsRuntime.InvokeAsync<object>("initGame", DotNetObjectReference.Create(this));
            _context = await _canvas.CreateCanvas2DAsync();
        }
    }

    [JSInvokable]
    public async ValueTask GameLoop(float timeStamp, int width, int height)
    {
        await _context.ClearRectAsync(0, 0, width, height);

        for (int i = 0; i < Game.Tiles.Count; i++)
        {
            if ((Game.Tiles[i].xPosition + Game.ScreenPositionX) < 1440 && (Game.Tiles[i].yPosition + Game.ScreenPositionY) < 880)
            {
                switch(Game.Tiles[i].TerrainType)
                {
                    case TerrainType.Plain:
                        await _context.DrawImageAsync(_plainTile, Game.Tiles[i].xPosition + Game.ScreenPositionX, Game.Tiles[i].yPosition + Game.ScreenPositionY, 100, 100);
                        break;

                    case TerrainType.Water:
                        await _context.DrawImageAsync(_waterTile, Game.Tiles[i].xPosition + Game.ScreenPositionX, Game.Tiles[i].yPosition + Game.ScreenPositionY, 100, 100);
                        break;

                    case TerrainType.Stone:
                        await _context.DrawImageAsync(_stoneTile, Game.Tiles[i].xPosition + Game.ScreenPositionX, Game.Tiles[i].yPosition + Game.ScreenPositionY, 100, 100);
                        break;

                    case TerrainType.Snow:
                        await _context.DrawImageAsync(_snowTile, Game.Tiles[i].xPosition + Game.ScreenPositionX, Game.Tiles[i].yPosition + Game.ScreenPositionY, 100, 100);
                        break;

                    case TerrainType.Magma:
                        await _context.DrawImageAsync(_magmaTile, Game.Tiles[i].xPosition + Game.ScreenPositionX, Game.Tiles[i].yPosition + Game.ScreenPositionY, 100, 100);
                        break;
                }
            }
        };

        for (int i = 0; i < Game.GameObjects.Count; i++)
        {
            await _context.DrawImageAsync(_orcWarrior, Game.GameObjects[i].xPosition + Game.ScreenPositionX,
                                                                                Game.GameObjects[i].yPosition + Game.ScreenPositionY, 80, 80);
        }
    }
}
